# Модуль 3
## Утилита для создания пользовательских задач 

### Как используются принципы ООП?
#### Инкапсуляция 
Каждый классы скрывают свою реализацию и предоставляют публичные интерфесы для взаимодействие с ними
#### Наследование и полифорфизм
Ярким примером наследования и там-же полифорфизма являются классы консольных команд, базовый класс и интерйес к ним.
#### Абстракция 
В качестве примеров абстракции реализованы интерфесы в прокте CalendarTasks.Defs например:
CalendarTasks.Defs.Calendar.IDateTimeProvider; - возможны варианты для провайдера даты и времени.  
CalendarTasks.Defs.CalendarTaskNumbers.ICalendarTaskNumberGenerator; - номер для задачи можно генерировать по разному.
и др.

### Какие патерны проектирования
Синглтон, правда на основе регистраций в DI
Провайдер вместо абстрактной фабрики
Консольные команды и CalendarTasks.Defs.ICalendarTaskHandler исходя из определения можно назвать фасадными
Из поведенческого команда

### Принципы SOLID
#### S  
 Любой обработчик в программе отвечает только за одну какую-то задачу.
#### O 
    Здесь есть вопрос к абстрактному классу. Добавление новой функциональности может потребовать изменить метод Execute, но с другой стороны
этот метод можно сделать виртуальным и переопределить в наследнике.    
#### L 
 Здесь не тот уровень наследования но если базовый класс не делать абстрактным и реализовать приватные методы, то принцип будет соблюден.
#### I
 Часть интерфейсов созданы в соответствии с приципом S и только для консольного приложения.  
#### D
  Все реализованные классы зависят от абстракций, разрешаемых через DI

#### Небольшая помарка
 Видимо я слишком широко интерпретировал задачу и не успел все, что хотел сделать. Прошу прощения заранее за больше количество кода.
Часть функционала сделать не успел. Оформлять и отлаживать все команды - довольно долго. Тесты считайте не писал. Местами наверное что-то будет ломаться. Но мне хотелось показать имменно сам подход.


